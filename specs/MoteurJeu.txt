service: MoteurJeu
types: enum RESULTAT{ORC_GAGNE, HUMAN_GAGNE, NUL},
enum COMMANDE{RIEN, DEPLACER, ENTRERMINE, ENTRERHOTELVILLE, TAPERMURAILLE}, int, boolean, Terrain
observators:
	const maxPasJeu : [MoteurJeu] → int
	terrain : [MoteurJeu] → Terrain
	pasJeuCourant : [MoteurJeu] → int
	estFini : [MoteurJeu] → boolean
	resultatFinal : [MoteurJeu] → RESULTAT
		pre resultatFinal(M) require estFini(M)

	peutEntrer : [MoteurJeu] × int × int → boolean
		pre peutEntrer(M, vilNum, minNum) require 
			¬Villageois::estMort(getVillageois(M, vilNum))  ∧
 0 ≤ minNum < |Terrain::getListeMine(terrain(M))| 
peutEntrerHotelVille : [MoteurJeu] × int × int → boolean
		pre peutEntrerHotelVille(M, vilNum, hdv) require
			¬Villageois::estMort(getVillageois(M, vilNum))  ∧
 0 ≤ hdv < |Terrain::getListeHotelVille(terrain(M))|
	peutTaperMuraille: [MoteurJeu] × int × int → boolean
		pre peutTaperMuraille(M, vilNum, mur) require
			¬Villageois::estMort(getVillageois(M, vilNum))  ∧
			¬Muraille::estDetruite(getMuraille(M, mur))
	getVillageois : [MoteurJeu] × int → Villageois
		pre getVillageois(M, vill) require
 0 ≤ vill < |Terrain::getListeVillageois(terrain(M))|
	getMine : [MoteurJeu] × int → Mine
		pre getMine(M, mi) require 
0 ≤ mi < |Terrain::getListeMine(terrain(M))|
getMuraille : [MoteurJeu] × int → Muraille
		pre getMuraille(M, mi) require 
0 ≤ mi < |Terrain::getListeMuraille(terrain(M))|
getHDV : [MoteurJeu] × int → HotelVille
		pre getHDV(M, hdv) require
 0 ≤ hdv < |Terrain::getListeHotelVille(terrain(M))|
constructors:
	init : Terrain × int → [MoteurJeu]
		pre init(T, maxPas) require maxPas > 0
operators:
	pasJeu : [MoteurJeu] × COMMANDE × int × int → [MoteurJeu]
		pre pasJeu(M, command, vilNum, arg) require
¬Villageois::estMort(getVillageois(M, vilNum)) ∧
¬Villageois::estOccupe(getVillageois(M, vilNum)) ∧
¬estFini(M) ∧
command = DEPLACER ⇒ 
0 ≤ arg ≤ 360 
command = ENTRERMINE ⇒ 
peutEntrer(M, vilNum, arg)
command = ENTRERHOTELVILLE ⇒ 
peutEntrerHotelVille(M, vilNum, arg)
command = TAPERMURAILLE ⇒ 
\not Muraille::estDetruite(getMuraille(M, arg))  \and
peutTaperMuraille(M, vilNum, arg)

observations:
[invariants]
	0 ≤ pasJeuCourant(M) ≤ maxPasJeu(M)
	estFini(M) min= ∃x | 0 ≤ x ≤ |Terrain::getListeHotelVille(terrain(M))| \and
HotelVille::orRestant(getHDV(M, x)) ≥ 1664 ∨
 pasJeuCourant(M) = maxPasJeu(M)
	resultatFinal(M) min=
ORC_GAGNE si ∃x | 0 ≤ x ≤ |Terrain::getListeHotelVille(terrain(M))| \and
HotelVille::orRestant(getHDV(M, x)) ≥ 1664 ∧ 
HotelVille::etatAppartenance(getHDV(M, x)) = ORC
HUMAN_GAGNE si ∃x | 0 ≤ x ≤ |Terrain::getListeHotelVille(terrain(M))| \and
HotelVille::orRestant(getHDV(M, x)) ≥ 1664 ∧ 
HotelVille::etatAppartenance(getHDV(M, x)) = HUMAN
NUL sinon

	getVillageois(M, vill) min= get(Terrain::getListeVillageois(terrain(M)), vill)
getMine(M, mi) min= get(Terrain::getListeMine(terrain(M)), mi)
getMuraille(M, mu) min= get(Terrain::getListeMuraille(terrain(M)), mu)
getHDV(M, hdv) min= get(Terrain::getListeHotelVille(terrain(M)), hdv)

Soit vilposX \def Villageois::posx(getVillageois(M, vill)),
	Soit vilposY \def Villageois::posy(getVillageois(M, vill)),
	Soit mineCenterX \def (Mine::posx(getMine(M, mi)) +Mine::largeur(getMine(M, mi))) / 2,
	Soit mineCenterY \def (Mine::posy(getMine(M, mi)) + Mine::hauteur(getMine(M, mi))) / 2,
	Soit hvCenterX \def (HotelVille::posx(getHDV(M, hdv)) + HotelVille::largeur(getHDV(M, hdv))) / 2,
	Soit hvCenterY \def (HotelVille::posy(getHDV(M, hdv)) + HotelVille::hauteur(getHDV(M, hdv))) / 2,
Soit murCenterX \def (Muraille::posx(getMuraille(M, mu)) +Muraille::largeur(getMuraille(M, mu))) / 2 ,
	Soit murCenterY \def (Muraille::posy(getMuraille(M, mu)) + Muraille::hauteur(getMuraille(M, mu))) / 2,

	peutEntrer(M, vill, mi) min= distance(vilposX, vilposY, mineCenterX, mineCenterY) ≤ 51 \and
 ¬Mine::estLaminee(getMine(M, mi))
peutEntrerHotelVille(M, vill, hdv) min= distance(vilposX, vilposY, hvCenterX,  hvCenterY)) ≤ 51 ∧   Villageois::race(getVillageois(M, vill)) = HotelVille::etatAppartenance(getHDV(M, hdv))
peutTaperMuraille(M, vill,mu) min= distance(vilposX, vilposY, murCenterX, murCenterY) ≤ 51

[init]
	terrain(init(t, m)) = t
	maxPasJeu(init(t, m)) = m
	pasJeuCourant(init(t, m)) = 0
	
[pasJeu]
	Soit Mpj \def pasJeu(M,c,vilNum,arg)
	pasJeuCourant(Mpj) = pasJeuCourant(M) + 1

	∀ x \in [0, |Terrain::getListeVillageois(terrain(M))|[, soit Vill \def getVillageois(M, x), 
	(Villageois::estOccupe(Vill) ⇒ getVillageois(Mpj, x) = Villageois::decrCorvee(Vill)) ∧ (Villageois::corvee(Vill) = 1 ⇒ terrain(Mpj) = Terrain::reinsertVillageois(terrain(M), x))

	∀ x \in [0, |Terrain::getListeMine(terrain(M))|[, soit Mi def= getMine(M, x),
	(\not Mine::estAbandonee(Mi) \and 
	(c = ENTRERMINE \a x != arg)) \impl getMine(Mpj, x) = Mine::abandoned(Mi)

	Soit Villpre \def getVillageois(M, vilNum)
	Soit Villpost \def getVillageois(Mpj, vilNum)
	Soit pArrivee \def GestionDeplacement::getPointArrivee(GestionDeplacement::calcChemin(GestionDeplacement::init(terrain(M), Villpre, arg)))
	c = DEPLACER \impl 
	Villpost = Villageois::setXY(Villpre, get(pArrivee, 0), get(pArrivee, 1)) \and 
	terrain(Mpj) = Terrain::moveVillageoisAt(terrain(M), vilNum, get(pArrivee, 0), get(pArrivee, 1))

	c = ENTRERHOTELVILLE \impl 
	getHDV(Mpj, arg) = HotelVille::depot(getHDV(M, arg), Villageois::quantiteOr(Villpre)) \and 
	Villpost = Villageois::dechargeOr(Villpre, Villageois::quantiteOr(Villpre))

	c = ENTRERMINE \impl 
getMine(Mpj, arg) = Mine::retrait(Mine::accueil(getMine(M, arg)) \and
			Villpost = Villageois::chargerOr(Villageois::setCorvee(Villpre, 16), 1) \and
terrain(Mpj) = Terrain::removeEntiteAt(terrain(M), EEntite.VILLAGEOIS, Villageois::posx(Villpre), Villageois::posy(Villpre), Villageois::largeur(Villpre), Villageois::hauteur(Villpre)) ∧ 
Villageois::posx(Villpost) = Mine::posx(getMine(M, arg)) ∧ 
Villageois::posy(Villpost) = Mine::posy(getMine(M, arg))
	c = TAPERMURAILLE \impl
		Soit Mur def= getMuraille(M, arg)
 		getMuraille(Mpj, arg) = 	Muraille::retrait(Mur, Villageois::force(Villpre)) \and
		Muraille::estDetruite(getMuraille(Mpj, arg)) ⇒ 
		terrain(Mpj) =  Terrain::removeEntiteAt(terrain(M), 
						MURAILLE,
						Muraille::posx(Mur), 
						Muraille::posy(Mur), 
						Muraille::largeur(Mur), 
						Muraille::hauteur(Mur))
	