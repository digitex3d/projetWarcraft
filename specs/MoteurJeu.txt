service : MoteurJeu
types : enum RESULTAT{GAGNE, PERDU},
enum COMMANDE{RIEN, DEPLACER, ENTRERMINE, ENTRERHOTELVILLE}
observators :
	const largeurTerrain : [MoteurJeu] → int
	const hauteurTerrain : [MoteurJeu] → int
	const maxPasJeu : [MoteurJeu] → int
	pasJeuCourant : [MoteurJeu] → int
	estFini : [MoteurJeu] → boolean
	resultatFinal : [MoteurJeu] → RESULTAT
		pre resultatFinal(M) require estFini(M)
	const numeroesVillageois : [MoteurJeu] → Set<int>
	getVillageois : [MoteurJeu] × int → Villageois
		pre getVillageois(M,num) require num ∈ numeroesVillageois(M,num)
	positionVillageoisX : [MoteurJeu] × int → int
		pre positionVillageoisX(M,num) require num ∈ numeroesVillageois(M,num)
	positionVillageoisY : [MoteurJeu] × int → int
		pre positionVillageoisY(M,num) require num ∈ numeroesVillageois(M,num)
	const numeroesMine : [MoteurJeu] → Set<int>
	getMine : [MoteurJeu] × int → Mine
		pre getMine(M,num) require num ∈ numeroesMine(M,num)
	const positionMineX : [MoteurJeu] × int → int
		pre positionMineX(M,num) require num ∈ numeroesMine(M,num)
	const positionMineY : [MoteurJeu] × int → int
		pre positionMineY(M,num) require num ∈ numeroesMine(M,num)
	hotelDeVille : [MoteurJeu] → HôtelVille
	const positionHotelVilleX : [MoteurJeu] → int
	const positionHotelVilleY : [MoteurJeu] → int
	peutEntrer : [MoteurJeu] × int × int → boolean
		pre peutEntrer(M,numVillageois,numMine) require numVillageois ∈ numeroesVillageois(M,numVillageois)
			∧ numMine ∈ numeroesMine(M,numMine)
	peutEntrerHotelVille : [MoteurJeu] × int → boolean
		pre peutEntrerHotelVille(M,numVillageois) require numVillageois ∈ numeroesVillageois(M,numVillageois)
Constructors :
	init : int × int × int → [MoteurJeu]
		pre init(largeur,hauteur,maxPas) require largeur≥ 600 ∧ hauteur≥ 400 ∧ maxPas≥ 0
Operators :
	pasJeu : [MoteurJeu] × COMMANDE × int × int → [MoteurJeu]
		pre pasJeu(M,commmand,numVillgeois,argument) require
						¬estFini(M)
						command=DEPLACER ⇒ 0 ≤argument≤ 360
						command=ENTRERMINE ⇒
								argument∈numeroesMines(M)
								peutEntrer(M,numVillageois,argument)
						command=ENTRERHOTELVILLE ⇒peutEntrerHotelVille(M,numVillageois)
Observations :
	[invariants]
	0 ≤ pasJeuCourant(M) ≤ maxPasJeu(M)
	estFini(M) min = HotelVille::orRestant(hotelDeVille(M)) ≥ 1664 ∨ pasJeuCourant(M)=maxPasJeu(M))
	resultatFinal(M)=GAGNE ⇔ HotelVille::orRestant(hotelDeVille(M)) ≥ 1664
	peutEntrer(M,numVillageois,numMine) min = distance(positionVillageoisX(M,numVillageois),positionVillageoisY(M,numVillageois),
	positionMineX(M,numMine),positionMineY(M,numMine)) ≤ 51
	peutEntrerHotelVille(M,numVillageois) min = distance(positionVillageoisX(M,numVillageois),positionVillageoisY(M,numVillageois),
	positionHotelVilleX(M),positionHotelVilleY(M)) ≤ 51
	[init]
	maxPasJeu(init(l,h,m))=m
	pasJeuCourant(init(l,h,m))=0
	largeurTerrain(init(l,h,m))=l
	hauteurTerrain(init(l,h,m))=h
	estFini(init(l,h,m))=False
	
	// Initialisation Hotel de ville
	positionHotelVilleX( init(l,h,m) ) <= 51 
	positionHotelVilleY( init(l,h,m) ) <= 51 
	HotelVille::orRestant( getHotelVille( init(l,h,m) ) ) = 16

	// Initialisation Villageois
	\forall numV \in numeroesVillageois:
		  positionVillageoisY(M, numV) - positionHotelVilleY(M) <= 51
	     	Ʌ  positionVillageoisX(M, numV) - positionHotelVilleX(M) <= 51
     	    Ʌ Villageois::pointsDeVie( getVillageois(M, numV) ) = 100
	    	Ʌ Villageois::quantiteOr( getVillageois(M, numV) ) = 0
	 		Ʌ Villageois::estMort( getVillageois(M, numV) ) = False

	// Initialisation Mines
	\forall numM \in numeroesMine:
		  positionMineY(M, numM) <= largeurTerrain
	     	Ʌ  positionMineX(M, numM) <= hauteurTerrain
     	     	Ʌ Mine::estAbandonne( getVillageois(M, numV) ) = True
	[pasJeu]
	pasJeuCourant(pasJeu(M,c,numVillageois,arg))=pasJeuCourant(M) +1
	getMine(pasJeu(M,c,numVillageois,arg),numMine) =
						Mine::abandoned(getMine(M,numMine)) si c6=ENTRERMINE ∨ arg6=numMine
						Mine::acceuil(getMine(M,numMine)) sinon
	getVillageois(pasJeu(M,c,numVillageois,arg),numVillageois) =                                                      							Villageois::dechargeOr(getVillageois(M,numVillageois),                                								Villageois::quantiteOr(getVillageois(M,numVillageois))) si c=ENTRERHOTELVILLE
    getHotelDeVille(pasJeu(M,c,numVillageois,arg),numVillageois) =                                     
			HotelVille:depot(getVillageois(M,numVillageois),                                          
						Villageois::quantiteOr(getVillageois(M,numVillageois))) si c=ENTRERHOTELVILLE      						    						