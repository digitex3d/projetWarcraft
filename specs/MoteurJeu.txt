service : MoteurJeu
types : enum RESULTAT{GAGNE, PERDU},
enum COMMANDE{RIEN, DEPLACER, ENTRERMINE, ENTRERHOTELVILLE}
observators :
	const largeurTerrain : [MoteurJeu] → int
	const hauteurTerrain : [MoteurJeu] → int
	const maxPasJeu : [MoteurJeu] → int
	pasJeuCourant : [MoteurJeu] → int
	estFini : [MoteurJeu] → boolean
	resultatFinal : [MoteurJeu] → RESULTAT
		pre resultatFinal(M) require estFini(M)
	const numeroesVillageois : [MoteurJeu] → Set<int>
	getVillageois : [MoteurJeu] × int → Villageois
		pre getVillageois(M,num) require num ∈ numeroesVillageois(M,num)
	positionVillageoisX : [MoteurJeu] × int → int
		pre positionVillageoisX(M,num) require num ∈ numeroesVillageois(M,num)
	positionVillageoisY : [MoteurJeu] × int → int
		pre positionVillageoisY(M,num) require num ∈ numeroesVillageois(M,num)
	const numeroesMine : [MoteurJeu] → Set<int>
	getMine : [MoteurJeu] × int → Mine
		pre getMine(M,num) require num ∈ numeroesMine(M,num)
	const positionMineX : [MoteurJeu] × int → int
		pre positionMineX(M,num) require num ∈ numeroesMine(M,num)
	const positionMineY : [MoteurJeu] × int → int
		pre positionMineY(M,num) require num ∈ numeroesMine(M,num)
	hotelDeVille : [MoteurJeu] → HôtelVille
	const positionHotelVilleX : [MoteurJeu] → int
	const positionHotelVilleY : [MoteurJeu] → int
	peutEntrer : [MoteurJeu] × int × int → boolean
		pre peutEntrer(M,numVillageois,numMine) require numVillageois ∈ numeroesVillageois(M,numVillageois)
			∧ numMine ∈ numeroesMine(M,numMine)
	peutEntrerHotelVille : [MoteurJeu] × int → boolean
		pre peutEntrerHotelVille(M,numVillageois) require numVillageois ∈ numeroesVillageois(M,numVillageois)
Constructors :
	init : int × int × int → [MoteurJeu]
		pre init(largeur,hauteur,maxPas) require largeur≥ 600 ∧ hauteur≥ 400 ∧ maxPas≥ 0
Operators :
	pasJeu : [MoteurJeu] × COMMANDE × int × int → [MoteurJeu]
		pre pasJeu(M,commmand,numVillgeois,argument) require
						¬estFini(M)
						command=DEPLACER ⇒ 0 ≤argument≤ 360
						command=ENTRERMINE ⇒
								argument∈numeroesMines(M)
								peutEntrer(M,numVillageois,argument)
						command=ENTRERHOTELVILLE ⇒peutEntrerHotelVille(M,numVillageois)
Observations :
	[invariants]
	0 ≤ pasJeuCourant(M) ≤ maxPasJeu(M)
	estFini(M) min = HotelVille::orRestant(hotelDeVille(M)) ≥ 1664 ∨ pasJeuCourant(M)=maxPasJeu(M))
	resultatFinal(M)=GAGNE ⇔ HotelVille::orRestant(hotelDeVille(M)) ≥ 1664
	peutEntrer(M,numVillageois,numMine) min = distance(positionVillageoisX(M,numVillageois),positionVillageoisY(M,numVillageois),
	positionMineX(M,numMine),positionMineY(M,numMine)) ≤ 51
	peutEntrerHotelVille(M,numVillageois) min = distance(positionVillageoisX(M,numVillageois),positionVillageoisY(M,numVillageois),
	positionHotelVilleX(M),positionHotelVilleY(M)) ≤ 51
	
	[init]
	maxPasJeu(init(l,h,m))=m
	pasJeuCourant(init(l,h,m))=0
	largeurTerrain(init(l,h,m))=l
	hauteurTerrain(init(l,h,m))=h
	
	// Initialisation Hotel de ville
	HotelVille::orRestant( getHotelVille( init(l,h,m) ) ) = 16

	// Initialisation Villageois
	\forall numV \in numeroesVillageois(init(l,h,m)): peutEntrerHotelVille(M, getVillageois(M, numV)) Ʌ Villageois::pointsDeVie( getVillageois(M, numV) ) = 100
	    	Ʌ Villageois::quantiteOr( getVillageois(M, numV) ) = 0
	 	Ʌ ¬ Villageois::estMort( getVillageois(M, numV) )

	// Initialisation Mines
	\forall numM \in numeroesMine:
		  positionMineX(M, numM) <= largeurTerrain
	     	Ʌ  positionMineY(M, numM) <= hauteurTerrain
     	     	Ʌ Mine::estAbandonne( getMine(M, numM) )
     	     	
[pasJeu]
	pasJeuCourant(pasJeu(M,c,numVillageois,arg))=pasJeuCourant(M)+1

	// Commande DEPLACER
	si c = DEPLACER	


	// Villageois
	\forall numV \in numeroesVillageois:
		getVillageois( pasJeu(M,c,numVillageois,arg), numV) =
			getVillageois( M, numV) si  numVillageois != numV
		
			positionVillageoisX(pasJeu(M,c,numVillageois,arg), numVillageois) = cos(arg) *  Villageois::vitesse(getVillageois(M,numVillageois))
			positionVillageoisY(pasJeu(M,c,numVillageois,arg), numVillageois) = sin(arg) *  Villageois::vitesse(getVillageois(M,numVillageois))
			

	// HotelDeVille
	getHotelDeVille(pasJeu(M,c,numVillageois,arg)) =  getHotelDeVille(M)
	

	// Commande ENTRERHOTELVILLE	
	si c = ENTRERHOTELVILLE		
	// Mines
	\forall numM \in numeroesMine:
		getMine(  pasJeu(M,c,numVillageois,arg), numM ) = getMine(  M, numM )

	// Villageois
	\forall numV \in (numeroesVillageois \minus numVillageois):
		getVillageois( pasJeu(M,c,numVillageois,arg), numV) =
			
	Villageois::quantiteOr(getVillageois(pasJeu(M,c,numVillageois,arg),numVillageois)))  = 0
			
	// HotelDeVille
    	HotelVille::quantiteOr( getHotelDeVille( pasJeu(M,c,numVillageois,arg) )  ) = 
		 HotelVille::quantiteOr( getHotelDeVille( M )) +
                     Villageois::quantiteOr(getVillageois(M,numVillageois))) 

	// Commande ENTRERMINE     
	si c = ENTRERMINE	         
	// Mines
	\forall numM \in ( numeroesMine \minus arg ):
		getMine(  pasJeu(M,c,numVillageois,arg), numM ) = getMine(  M, numM )
	
	Mine::quantiteOr(getMine(  pasJeu(M,c,numVillageois,arg), arg )) = 
		Mine::quantiteOr ( getMine( M , arg))-1

	// Villageois
	\forall numV \in (numeroesVillageois \minus numVillageois):
		getVillageois( pasJeu(M,c,numVillageois,arg), numV) =
			
	Villageois::quantiteOr(getVillageois(pasJeu(M,c,numVillageois,arg),numVillageois)))  = Villageois::quantiteOr(getVillageois(M,numVillageois)))+1
			
	// HotelDeVille
	getHotelDeVille(pasJeu(M,c,numVillageois,arg)) =  getHotelDeVille(M)
    						    						